/*
 * A small and specific palette of expression factories.
 *
 * Using these factories, a finite set of expressions can be built 
 * such that all possible values encountered during the tkf91 dynamic
 * programming will be generated by integer linear combinations of
 * expressions in that set.
 *
 * These simple expressions are defined in such a seemingly unnecessarily
 * abstract way so that they can be used polymorphically
 * even though C does not have convenient mechanisms for polymorphism.
 *
 * Note that the mathematical value of an expression object
 * must never change over the entire lifetime of that object.
 * Its constant mathematical value may be evaluated at various
 * levels of log2 bits of precision to attempt to meet error bounds
 * acceptable for the application. These evaluations are cached.
 *
 * In the following data types, fmpz_t and fmpq_t are from the FLINT library,
 * whereas expr_t is from the ad-hoc 'femtocas' module.
 *
 * -- data types --
 * fmpz_t : i
 * fmpq_t : a, b, t, p
 * expr_t : x
 *
 * -- expressions --
 * rational(a)      : a
 * exp(a)           : exp(a)
 * logint(i)        : log(i)
 * logexpr(x)       : log(x)
 * logpartial(p, x) : log((1 - p)*x + p)
 * log1mexpr(x)     : log(1 - x)
 * tkfbeta(a, b, t) : (exp(b*t) - exp(a*t)) / (b*exp(b*t) - a*exp(a*t))
 * tkfbc1(a, x)     : log(1 - a*x)
 * tkfbc2(b, t, x)  : log(1 - exp(-b*t) - x)
 */

/*
 * This is a node in a registry of mathematical expressions.
 * It is not very clever, and it doesn't allocate or free memory by itself.
 */
typedef struct reg_node_struct
{
    slong index;
    expr_ptr p;
    struct reg_node_struct * next;
} reg_node_struct;

typedef reg_node_struct * reg_node_ptr;
typedef reg_node_struct reg_node_t[1];

void
reg_node_init(reg_node_t x, slong index, expr_ptr p)
{
    x->index = index;
    x->p = p;
    x->next = NULL;
}

void
reg_node_clear(reg_node_t x)
{
    x->index = -1;
    x->p = NULL;
    x->next = NULL;
}


/*
 * This structure manages the memory of all of its registry nodes
 * and all of the expression objects in those nodes.
 */
typedef struct
{
    reg_node_ptr head;
    reg_node_ptr tail;
    slong size;
} reg_struct;

typedef reg_struct reg_t[1];
typedef reg_struct * reg_ptr;

void
reg_init(reg_ptr x)
{
    x->head = NULL;
    x->tail = NULL;
    x->size = 0;
}

void
reg_clear(reg_ptr x)
{
    slong i;
    reg_node_ptr node, next;
    i = 0;
    node = x->head;
    while (node)
    {
        next = x->next;
        if (node->index != i)
        {
            flint_printf("found a node out of order ");
            flint_printf("when clearing a list of expressions");
            abort();
        }
        if (next == NULL && node != x->tail)
        {
            flint_printf("reached the end of a list ");
            flint_printf("before reaching the tail");
            abort();
        }
        expr_clear(node->p);
        flint_free(node->p);
        reg_node_clear(node);
        flint_free(node);
        node = next;
        i++;
    }
    x->head = NULL;
    x->tail = NULL;
    x->size = 0;
}

expr_ptr
reg_new(reg_ptr x)
{
    reg_node_ptr node;
    expr = (expr_ptr) flint_malloc(sizeof(expr_struct));
    node = (reg_node_ptr) flint_malloc(sizeof(reg_node_struct));
    expr->userdata = node;
    reg_node_init(node, x->size, expr);
    if (x->size)
    {
        x->tail->next = node;
    }
    else
    {
        x->head = node;
    }
    x->tail = node;
    x->size += 1;
    return expr;
}


typedef struct
{
    fmpq qi[4];
    fmpq_t negdt;
    fmpq_t lambda_div_mu;
    fmpq_t one_minus_lambda_div_mu;
    fmpq_t beta_exponent;
    fmpq_t neg_mu_tau;
} rational_intermediates_struct;

typedef rational_intermediates_struct rational_intermediates_t[1];

void
rational_intermediates_init(rational_intermediates_t q,
        fmpq_ptr lambda, fmpq_ptr mu, fmpq_ptr tau, fmpq_ptr pi)
{
    slong i;

    fmpq_t one;

    fmpq_init(one);
    fmpq_one(one);

    /* initialize qi */
    {
        for (i = 0; i < 4; i++)
        {
            fmpq_init(q->qi+i);
            fmpq_sub(q->qi+i, one, pi+i);
        }
    }

    /* initialize negdt */
    {
        fmpq_t dt;
        fmpq_init(dt);
        fmpq_init(q->negdt);
        fmpq_one(dt);
        for (i = 0; i < 4; i++)
        {
            fmpq_submul(dt, pi+i, pi+i);
        }
        fmpq_div(dt, tau, dt);
        fmpq_neg(q->negdt, dt);
        fmpq_clear(dt);
    }

    /* initialize rational values related to gamma */
    {
        fmpq_init(q->lambda_div_mu);
        fmpq_init(q->one_minus_lambda_div_mu);
        fmpq_div(q->lambda_div_mu, lambda, mu);
        fmpq_sub(q->one_minus_lambda_div_mu, one, q->lambda_div_mu);
    }

    /* initialize rational values related to beta */
    {
        fmpq_t lambda_minus_mu;
        fmpq_init(lambda_minus_mu);
        fmpq_sub(lambda_minus_mu, lambda, mu);
        fmpq__init(q->beta_exponent);
        fmpq_mul(q->beta_exponent, lambda_minus_mu, tau);
        fmpq_clear(lambda_minus_mu);
    }

    /* -mu*tau */
    {
        fmpq_t mu_tau;
        fmpq_init(mu_tau);
        fmpq_mul(mu_tau, mu, tau);
        fmpq_init(q->neg_mu_tau);
        fmpq_neg(q->neg_mu_tau, mu_tau);
        fmpq_clear(mu_tau);
    }

    fmpq_clear(one);
}

void
rational_intermediates_clear(rational_intermediates_t q)
{
    slong i;
    for (i = 0; i < 4; i++)
    {
        fmpq_clear(q->qi+i);
    }
    fmpq_clear(q->negdt);
    fmpq_clear(q->lambda_div_mu);
    fmpq_clear(q->one_minus_lambda_div_mu);
    fmpq_clear(q->beta_exponent);
    fmpq_clear(q->neg_mu_tau);
}


/*
 * This is just an aggregate of named expression pointers.
 * The structure does not manage the memory used by the expressions.
 */
typedef struct
{
    /* factors related to sequence length equilibrium frequency */
    expr_ptr one_minus_lambda_div_mu;
    expr_ptr lambda_div_mu;

    /* factors related to sequence composition */
    expr_ptr pi[4];

    /* factors related to the indel process involving beta */
    expr_ptr exp_neg_mu_tau;
    expr_ptr one_minus_lambda_beta;
    expr_ptr lambda_beta;
    expr_ptr the_long_beta_expression; /* 1 - exp(-mu*t) - mu*beta */
    expr_ptr mu_beta;

    /* factors related to point substitutions */
    expr_ptr match[4];
    expr_ptr mismatch[4];

} tkf91_expressions_struct;

typedef tkf91_expressions_struct * tkf91_expressions_ptr;
typedef tkf91_expressions_struct tkf91_expressions_t[1];




void
tkf91_expressions_init(
        expressions_registry_t reg,
        basis_expressions_t p,
        slong *A, slong Alen,
        slong *B, slong Blen,
        fmpq_t lambda,
        fmpq_t mu,
        fmpq_t tau,
        fmpq_t pi[4])
{
    /*
     * Create a bunch of static single assignment expressions.
     * Track all of them in an expressions registry;
     * this will let the expressions be cleared later,
     * and it will associate each expression with an array index.
     * Give some of the expressions special names to be used
     * later when the generators are defined.
     */
    slong i, j;

    rational_intermediates_t q;
    rational_intermediates_init(q, lambda, mu, tau, pi);

    /* factors related to sequence length equilibrium frequency */
    {
        p->lambda_div_mu = reg_new(reg);
        expr_fmpq(p->lambda_div_mu, q->lambda_div_mu);

        p->one_minus_lambda_div_mu = reg_new(reg);
        expr_fmpq(p->one_minus_lambda_div_mu, q->one_minus_lambda_div_mu);
    }

    /* factors related to sequence composition */
    {
        expr_ptr alias;
        for (i = 0; i < 4; i++)
        {
            alias = NULL;
            for (j = 0; j < i; j++)
            {
                if (fmpq_equal(pi+i, pi+j))
                {
                    alias = p->pi+j;
                }
            }
            if (alias)
            {
                p->pi+i = alias;
            }
            else
            {
                p->pi+i = reg_new(reg);
                expr_fmpq(p->pi+i, pi+i);
            }
        }
    }

    rational_intermediates_clear(q);
}


int tkf_expressions()
{
    fmpq_t a, b, t;
    fmpq_t at, bt;

    fmpq_init(a);
    fmpq_init(b);
    fmpq_init(t);

    fmpq_set_si(a, 1, 2);
    fmpq_set_si(b, 3, 4);
    fmpq_set_si(t, 5, 6);

    fmpq_init(at);
    fmpq_init(bt);

    fmpq_mul(at, a, t);
    fmpq_mul(bt, b, t);

    expr_t ax, bx;
    expr_t eat, ebt, aeat, bebt;
    expr_t num, den;
    expr_t res;

    expr_fmpq(ax, a);
    expr_fmpq(bx, b);
    expr_exp_fmpq(ebt, bt);
    expr_exp_fmpq(eat, at);
    expr_mul(bebt, bx, ebt);
    expr_mul(aeat, ax, eat);
    expr_sub(num, ebt, eat);
    expr_sub(den, bebt, aeat);
    expr_div(res, num, den);

    arb_t value;
    slong level;

    arb_init(value);

    for (level = 0; level < 8; level++)
    {
        flint_printf("evaluating ");
        expr_print(res);
        flint_printf(" at level %wd:\n", level);
        expr_eval(value, res, level);
        arb_print(value);
        flint_printf("\n\n");
    }

    arb_clear(value);
    fmpq_clear(a);
    fmpq_clear(b);
    fmpq_clear(t);
    expr_clear(ax);
    expr_clear(bx);
    expr_clear(eat);
    expr_clear(ebt);
    expr_clear(aeat);
    expr_clear(bebt);
    expr_clear(num);
    expr_clear(den);
    expr_clear(res);

    return 0;
}



/* helper functions */


void
_fmpq_init_set(fmpq_t z, const fmpq_t x)
{
    fmpq_init(z);
    fmpq_set(z, x);
}

void
_arb_init_set_fmpq(arb_t z, const fmpq_t u, slong prec)
{
    arb_init(z);
    arb_set_fmpq(z, u, prec);
}


/* definitions */


typedef struct
{
    fmpq a;
    fmpq b;
    fmpq t;
} beta_data_struct;

typedef beta_data_struct * beta_data_ptr;

void
beta_expr_init(expr_ptr x, const fmpq_t a, const fmpq_t b, const fmpq_t t)
{
    beta_data_ptr d;

    d = flint_malloc(sizeof(beta_data_struct));
    _fmpq_init_set(&(d->a), a);
    _fmpq_init_set(&(d->b), b);
    _fmpq_init_set(&(d->t), t);

    expr_init(x);
    x->data = d;
    x->clear = &beta_expr_clear;
    x->print = &beta_expr_print;
    x->eval = &beta_expr_eval;
}

void
beta_expr_clear(expr_data_ptr data)
{
    beta_data_ptr d = (beta_data_ptr) data;
    fmpq_clear(&(d->a));
    fmpq_clear(&(d->b));
    fmpq_clear(&(d->t));
    flint_free(d);
}

void
beta_expr_print(expr_data_ptr data)
{
    beta_data_ptr d = (beta_data_ptr) data;
    flint_printf("beta(");
    fmpq_print(&(d->a)); flint_printf(", ");
    fmpq_print(&(d->b)); flint_printf(", ");
    fmpq_print(&(d->t));
    flint_printf(")");
}

void
beta_expr_eval(arb_t res, expr_data_ptr data, slong level)
{
    slong prec;
    beta_data_ptr d;
    fmpq_t at, bt;
    arb_t ax, bx, atx, btx;
    arb_t eatx, ebtx;
    arb_t num, den;

    prec = 1 << level;
    d = (beta_data_ptr) data;

    fmpq_init(at);
    fmpq_mul(at, &(d->a), &(d->t));

    fmpq_init(bt);
    fmpq_mul(bt, &(d->b), &(d->t));

    _arb_init_set_fmpq(ax, &(d->a), prec);
    _arb_init_set_fmpq(bx, &(d->b), prec);
    _arb_init_set_fmpq(atx, at, prec);
    _arb_init_set_fmpq(btx, bt, prec);

    arb_init(eatx);
    arb_exp(eatx, atx, prec);

    arb_init(ebtx);
    arb_exp(ebtx, btx, prec);

    arb_init(num);
    arb_sub(num, ebtx, eatx, prec);

    arb_init(den);
    arb_mul(den, bx, ebtx, prec);
    arb_submul(den, ax, eatx, prec);

    arb_div(res, num, den, prec);

    fmpq_clear(at);
    fmpq_clear(bt);

    arb_clear(ax);
    arb_clear(bx);
    arb_clear(atx);
    arb_clear(btx);

    arb_clear(eatx);
    arb_clear(ebtx);

    arb_clear(num);
    arb_clear(den);
}


/* three other expressions in the 'beta complex' */


typedef struct
{
    fmpq a;
    expr_ptr beta;
} bc1_data_struct;

typedef bc1_data_struct * bc1_data_ptr;

void
bc1_expr_init(expr_ptr x, const fmpq_t a, expr_ptr beta)
{
    bc1_data_ptr d;

    d = flint_malloc(sizeof(bc1_data_struct));
    _fmpq_init_set(&(d->a), a);
    d->beta = beta;

    expr_init(x);
    x->data = d;
    x->clear = &bc1_expr_clear;
    x->print = &bc1_expr_print;
    x->eval = &bc1_expr_eval;
}

void
bc1_expr_clear(expr_data_ptr data)
{
    bc1_data_ptr d = (bc1_data_ptr) data;
    fmpq_clear(&(d->a));
    flint_free(d);
}

void
bc1_expr_print(expr_data_ptr data)
{
    bc1_data_ptr d = (bc1_data_ptr) data;
    flint_printf("bc1(");
    fmpq_print(&(d->a)); flint_printf(", beta(...))");
}

void
bc1_expr_eval(arb_t res, expr_data_ptr data, slong level)
{
    arb_t v;
    bc1_data_ptr d;

    arb_init(v);

    d = (bc1_data_ptr) data;
    expr_eval(v, d->beta, level);

    arb_clear(v);
}


/* demonstrate usage of the beta expression */


int main()
{
    slong level;
    fmpq_t a, b, t;
    arb_t value;
    expr_t x;

    fmpq_init(a);
    fmpq_init(b);
    fmpq_init(t);

    fmpq_set_si(a, 1, 2);
    fmpq_set_si(b, 3, 4);
    fmpq_set_si(t, 5, 6);

    beta_expr_init(x, a, b, t);
    arb_init(value);

    for (level = 0; level < 8; level++)
    {
        flint_printf("evaluating ");
        expr_print(x);
        flint_printf(" at level %wd:\n", level);
        expr_eval(value, x, level);
        arb_print(value);
        flint_printf("\n\n");
    }

    fmpq_clear(a);
    fmpq_clear(b);
    fmpq_clear(t);
    arb_clear(value);
    expr_clear(x);

    return 0;
}
